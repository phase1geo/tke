# TKE - Advanced Programmer's Editor
# Copyright (C) 2014-2016  Trevor Williams (phase1geo@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

######################################################################
# Name:    emmet_lexer.fcl
# Author:  Trevor Williams  (phase1geo@gmail.com)
# Date:    2/17/2016
# Brief:   Lexer for emmet syntax.
######################################################################

source [file join $::tke_dir lib emmet_parser.tab.tcl]

array set emmet_block_aliases {

  # HTML
  doc       {html>(head>meta[charset=UTF-8]+title{Document})+body}
  doc4      {html>(head>meta[http-equiv="Content-Type" content="text/html;charset=${charset}"]+title{Document})+body}
  html:4t   {!!!4t+doc4[lang=en]}
  html:4s   {!!!4s+doc4[lang=en]}
  html:xt   {!!!xt+doc4[xmlns="http://www.w3.org/1999/xhtml" xml:lang=en]}
  html:xs   {!!!xs+doc4[xmlns="http://www.w3.org/1999/xhtml" xml:lang=en]}
  html:xxs  {!!!xxs+doc4[xmlns="http://www.w3.org/1999/xhtml" xml:lang=en]}
  html:5    {!!!+doc[lang=en]}
  ol+       {ol>li}
  dl+       {dl>dt+dd}
  map+      {map>area}
  table+    {table>tr>td}
  colgroup+ {colgroup>col}
  colg+     {colgroup>col}
  tr+       {tr>td}
  select+   {select>option}
  optgroup+ {optgroup>option}
  optg+     {optgroup>option}
  
  # CSS

  # XSLT
  choose+   {xml:choose>xsl:when+xsl:otherwise}
  xsl       {xsl:stylesheet[version=1.0 xmlns:xsl="http://www.w3.org/1999/XSL/Transform"]}
}

proc emmet_get_item_name {str} {

  set formatted_str ""
  set values        [list]

  while {[set index [string first \$ $str]] != -1} {
    append formatted_str [string range $str 0 [expr $index - 1]]
    regexp {^(\$+)(@(-)?(\d*))?(.*)$} [string range $str $index end] match numbering dummy reverse start rest
    append formatted_str "%0[string length $numbering]d"
    if {$dummy ne ""} {
      if {$reverse ne ""} {
        if {$start ne ""} {
          lappend values [list expr (\$::emmet_max - \$::emmet_curr) + ($start - 1)]
        } else {
          lappend values [list expr \$::emmet_max - \$::emmet_curr]
        }
      } else {
        if {$start ne ""} {
          lappend values [list expr \$::emmet_curr + $start]
        } else {
          lappend values [list expr \$::emmet_curr + 1]
        }
      }
    } else {
      lappend values [list expr \$::emmet_curr + 1]
    }
    set str [string range $str [expr $index + [string length $match]] end]
  }

  append formatted_str $str

  return [list $formatted_str $values]

}

proc emmet_get_matching {str start end} {
  
  set strlen [string length $str]
  set count  1
  set skip   0
  
  for {set i 1} {$i < $strlen} {incr i} {
    if {$skip} {
      set skip 0
    } else {
      set char [string index $str $i]
      if {$char eq "\\"} {
        set skip 1
      } elseif {$char eq $end} {
        if {[incr count -1] == 0} {
          unput [string range $str [expr $i + 1] end]
          return [string range $str 1 [expr $i - 1]]
        }
      } elseif {$char eq $start} {
        incr count
      }
    }
  }
  
}


######
# Begin autogenerated fickle (version 2.04) routines.
# Although fickle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/fickle for other details.
######

# If emmet_wrap() returns false (zero), then it is assumed that the
# function has gone ahead and set up emmet_in to point to another input
# file, and scanning continues.  If it returns true (non-zero), then
# the scanner terminates, returning 0 to its caller.  Note that in
# either case, the start condition remains unchanged; it does not
# revert to INITIAL.
#   -- from the flex(1) man page
proc emmet_wrap {} {
    return 1
}

# ECHO copies emmet_text to the scanner's output if no arguments are
# given.  The scanner writes its ECHO output to the emmet_out global
# (default, stdout), which may be redefined by the user simply by
# assigning it to some other channel.
#   -- from the flex(1) man page
proc ECHO {{s ""}} {
    if {$s == ""} {
        puts -nonewline $::emmet_out $::emmet_text
    } else {
        puts -nonewline $::emmet_out $s
    }
}

# EMMET__FLUSH_BUFFER flushes the scanner's internal buffer so that the
# next time the scanner attempts to match a token, it will first
# refill the buffer using EMMET__INPUT.
#   -- from the flex(1) man page
proc EMMET__FLUSH_BUFFER {} {
    set ::emmet__buffer ""
    set ::emmet__index 0
    set ::emmet__done 0
}

# emmet_restart(new_file) may be called to point emmet_in at the new input
# file.  The switch-over to the new file is immediate (any previously
# buffered-up input is lost).  Note that calling emmet_restart with emmet_in
# as an argument thus throws away the current input buffer and
# continues scanning the same input file.
#   -- from the flex(1) man page
proc emmet_restart {new_file} {
    set ::emmet_in $new_file
    EMMET__FLUSH_BUFFER
}

# The nature of how it gets its input can be controlled by defining
# the EMMET__INPUT macro.  EMMET__INPUT's calling sequence is
# "EMMET__INPUT(buf,result,max_size)".  Its action is to place up to
# max_size characters in the character array buf and return in the
# integer variable result either the number of characters read or the
# constant EMMET__NULL (0 on Unix systems) to indicate EOF.  The default
# EMMET__INPUT reads from the global file-pointer "emmet_in".
#   -- from the flex(1) man page
proc EMMET__INPUT {buf result max_size} {
    upvar $result ret_val
    upvar $buf new_data
    if {$::emmet_in != ""} {
        set new_data [read $::emmet_in $max_size]
        set ret_val [string length $new_data]
    } else {
        set new_data ""
        set ret_val 0
    }
}

# yy_scan_string sets up input buffers for scanning in-memory
# strings instead of files.  Note that switching input sources does
# not change the start condition.
#   -- from the flex(1) man page
proc emmet__scan_string {str} {
    append ::emmet__buffer $str
    set ::emmet_in ""
}

# unput(c) puts the character c back onto the input stream.  It will
# be the next character scanned.
#   -- from the flex(1) man page
proc unput {c} {
    set s [string range $::emmet__buffer 0 [expr {$::emmet__index - 1}]]
    append s $c
    set ::emmet__buffer [append s [string range $::emmet__buffer $::emmet__index end]]
}

# Returns all but the first n characters of the current token back to
# the input stream, where they will be rescanned when the scanner
# looks for the next match.  emmet_text and emmet_leng are adjusted
# appropriately.
#   -- from the flex(1) man page
proc emmet_less {n} {
    set s [string range $::emmet__buffer 0 [expr {$::emmet__index - 1}]]
    append s [string range $::emmet_text $n end]
    set ::emmet__buffer [append s [string range $::emmet__buffer $::emmet__index end]]
    set ::emmet_text [string range $::emmet_text 0 [expr {$n - 1}]]
    set ::emmet_leng [string length $::emmet_text]
}

# input() reads the next character from the input stream.
#   -- from the flex(1) man page
proc input {} {
    if {[string length $::emmet__buffer] - $::emmet__index < 1024} {
       set new_buffer_size 0
       if {$::emmet__done == 0} {
           EMMET__INPUT new_buffer new_buffer_size 1024
           append ::emmet__buffer $new_buffer
           if {$new_buffer_size == 0} {
               set ::emmet__done 1
           }
       }
       if $::emmet__done {
           if {[emmet_wrap] == 0} {
               return [input]
           } elseif {[string length $::emmet__buffer] - $::emmet__index == 0} {
               return {}
           }
        }
    }
    set c [string index $::emmet__buffer $::emmet__index]
    incr ::emmet__index
    return $c
}

# Pushes the current start condition onto the top of the start
# condition stack and switches to new_state as though you had used
# BEGIN new_state.
#   -- from the flex(1) man page
proc emmet__push_state {new_state} {
    lappend ::emmet__state_stack $new_state
}

# Pops off the top of the state stack; if the stack is now empty, then
# pushes the state "INITIAL".
#   -- from the flex(1) man page
proc emmet__pop_state {} {
    set ::emmet__state_stack [lrange $::emmet__state_stack 0 end-1]
    if {$::emmet__state_stack == ""} {
        emmet__push_state INITIAL
    }
}

# Returns the top of the stack without altering the stack's contents.
#   -- from the flex(1) man page
proc emmet__top_state {} {
    return [lindex $::emmet__state_stack end]
}

# BEGIN followed by the name of a start condition places the scanner
# in the corresponding start condition. . . .Until the next BEGIN
# action is executed, rules with the given start condition will be
# active and rules with other start conditions will be inactive.  If
# the start condition is inclusive, then rules with no start
# conditions at all will also be active.  If it is exclusive, then
# only rules qualified with the start condition will be active.
#   -- from the flex(1) man page
proc BEGIN {new_state {prefix emmet_}} {
    eval set ::${prefix}_state_stack [lrange \$::${prefix}_state_stack 0 end-1]
    eval lappend ::${prefix}_state_stack $new_state
}

# initialize values used by the lexer
set ::emmet_text {}
set ::emmet_leng 0
set ::emmet__buffer {}
set ::emmet__index 0
set ::emmet__done 0
set ::emmet__state_stack {}
BEGIN INITIAL
array set ::emmet__state_table {INITIAL 1}
if {![info exists ::emmet_in]} {
    set ::emmet_in "stdin"
}
if {![info exists ::emmet_out]} {
    set ::emmet_out "stdout"
}

######
# autogenerated emmet_lex function created by fickle
######

# Whenever yylex() is called, it scans tokens from the global input
# file yyin (which defaults to stdin).  It continues until it either
# reaches an end-of-file (at which point it returns the value 0) or
# one of its actions executes a return statement.
#   -- from the flex(1) man page
proc emmet_lex {} {
    upvar #0 ::emmet_text emmet_text
    upvar #0 ::emmet_leng emmet_leng
    while {1} {
        set emmet__current_state [emmet__top_state]
        if {[string length $::emmet__buffer] - $::emmet__index < 1024} {
            if {$::emmet__done == 0} {
                set emmet__new_buffer ""
                EMMET__INPUT emmet__new_buffer emmet__buffer_size 1024
                append ::emmet__buffer $emmet__new_buffer
                if {$emmet__buffer_size == 0 && \
                        [string length $::emmet__buffer] - $::emmet__index == 0} {
                    set ::emmet__done 1
                }
            }
            if $::emmet__done {
                if {[emmet_wrap] == 0} {
                    set ::emmet__done 0
                    continue
                } elseif {[string length $::emmet__buffer] - $::emmet__index == 0} {
                    break
                }
            }            
        }
        set ::emmet_leng 0
        set emmet__matched_rule -1
        # rule 0: [ \n\t\b\f]+
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A([ \n\t\b\f]+)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 0
        }
        # rule 1: [a-zA-Z$!][a-zA-Z0-9:!@$-]*\+?
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A([a-zA-Z$!][a-zA-Z0-9:!@$-]*\+?)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 1
        }
        # rule 2: [1-9][0-9.]*
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A([1-9][0-9.]*)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 2
        }
        # rule 3: \>
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\>)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 3
        }
        # rule 4: \+
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\+)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 4
        }
        # rule 5: \^+
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\^+)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 5
        }
        # rule 6: \(
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\()} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 6
        }
        # rule 7: \)
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\))} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 7
        }
        # rule 8: \*
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\*)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 8
        }
        # rule 9: \[
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\[)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 9
        }
        # rule 10: \]
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\])} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 10
        }
        # rule 11: \{.+\}
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\{.+\})} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 11
        }
        # rule 12: '.*'
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A('.*')} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 12
        }
        # rule 13: \".*\"
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\".*\")} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 13
        }
        # rule 14: =
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(=)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 14
        }
        # rule 15: \#
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\#)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 15
        }
        # rule 16: \.
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(\.)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 16
        }
        # rule 17: .
        if {$::emmet__state_table($emmet__current_state) && \
                [regexp -start $::emmet__index -indices -line  -- {\A(.)} $::emmet__buffer emmet__match] > 0 && \
                [lindex $emmet__match 1] - $::emmet__index + 1 > $::emmet_leng} {
            set ::emmet_text [string range $::emmet__buffer $::emmet__index [lindex $emmet__match 1]]
            set ::emmet_leng [string length $::emmet_text]
            set emmet__matched_rule 17
        }
        if {$emmet__matched_rule == -1} {
            set ::emmet_text [string index $::emmet__buffer $::emmet__index]
            set ::emmet_leng 1
        }
        incr ::emmet__index $::emmet_leng
        # workaround for Tcl's circumflex behavior
        if {[string index $::emmet_text end] == "\n"} {
            set ::emmet__buffer [string range $::emmet__buffer $::emmet__index end]
            set ::emmet__index 0
        }
        switch -- $emmet__matched_rule {
            0 {
set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos [string length $emmet_text]
            }
            1 {
if {[info exists ::emmet_block_aliases($emmet_text)]} {
    unput $::emmet_block_aliases($emmet_text)
  } else {
    if {[string index $emmet_text end] eq "+"} {
      unput "+"
      set emmet_text [string range $emmet_text 0 end-1]
    }
    set ::emmet_lval [emmet_get_item_name $emmet_text]
    set ::emmet_begpos $::emmet_endpos
    incr ::emmet_endpos [string length $emmet_text]
    return $::IDENTIFIER
  }
            }
            2 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos [string length $emmet_text]
  return $::NUMBER
            }
            3 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::CHILD
            }
            4 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::SIBLING
            }
            5 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos [string length $emmet_text]
  return $::CLIMB
            }
            6 {
set ::emmet_lval [llength [$::emmet_dom children root]]
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::OPEN_GROUP
            }
            7 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::CLOSE_GROUP
            }
            8 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::MULTIPLY
            }
            9 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::OPEN_ATTR
            }
            10 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::CLOSE_ATTR
            }
            11 {
set ::emmet_lval [emmet_get_item_name [emmet_get_matching $emmet_text \{ \}]]
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos [string length $emmet_text]
  return $::TEXT
            }
            12 {
set ::emmet_lval [emmet_get_item_name [emmet_get_matching $emmet_text \' \']]
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos [string length $emmet_text]
  return $::VALUE
            }
            13 {
set ::emmet_lval [emmet_get_item_name [emmet_get_matching $emmet_text \" \"]]
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos [string length $emmet_text]
  return $::VALUE
            }
            14 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::ASSIGN
            }
            15 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::ID
            }
            16 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emmet_endpos
  return $::CLASS
            }
            17 {
set ::emmet_lval $emmet_text
  set ::emmet_begpos $::emmet_endpos
  incr ::emment_endpos [string length $emmet_text]
  return $emmet_text
            }
            default
                { ECHO }
        }
    }
    return 0
}
######
# end autogenerated fickle functions
######

