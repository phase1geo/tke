# TKE - Advanced Programmer's Editor
# Copyright (C) 2014-2018  Trevor Williams (phase1geo@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

######################################################################
# Name:    format_parser.fcl
# Author:  Trevor Williams  (phase1geo@gmail.com)
# Date:    8/10/2015
# Brief:   Lexer for snippet format strings.
######################################################################

source [file join $::tke_dir lib format_parser.tab.tcl]

######
# Begin autogenerated fickle (version 2.04) routines.
# Although fickle itself is protected by the GNU Public License (GPL)
# all user-supplied functions are protected by their respective
# author's license.  See http://mini.net/tcl/fickle for other details.
######

# If format_wrap() returns false (zero), then it is assumed that the
# function has gone ahead and set up format_in to point to another input
# file, and scanning continues.  If it returns true (non-zero), then
# the scanner terminates, returning 0 to its caller.  Note that in
# either case, the start condition remains unchanged; it does not
# revert to INITIAL.
#   -- from the flex(1) man page
proc format_wrap {} {
    return 1
}

# ECHO copies format_text to the scanner's output if no arguments are
# given.  The scanner writes its ECHO output to the format_out global
# (default, stdout), which may be redefined by the user simply by
# assigning it to some other channel.
#   -- from the flex(1) man page
proc ECHO {{s ""}} {
    if {$s == ""} {
        puts -nonewline $::format_out $::format_text
    } else {
        puts -nonewline $::format_out $s
    }
}

# FORMAT__FLUSH_BUFFER flushes the scanner's internal buffer so that the
# next time the scanner attempts to match a token, it will first
# refill the buffer using FORMAT__INPUT.
#   -- from the flex(1) man page
proc FORMAT__FLUSH_BUFFER {} {
    set ::format__buffer ""
    set ::format__index 0
    set ::format__done 0
}

# format_restart(new_file) may be called to point format_in at the new input
# file.  The switch-over to the new file is immediate (any previously
# buffered-up input is lost).  Note that calling format_restart with format_in
# as an argument thus throws away the current input buffer and
# continues scanning the same input file.
#   -- from the flex(1) man page
proc format_restart {new_file} {
    set ::format_in $new_file
    FORMAT__FLUSH_BUFFER
}

# The nature of how it gets its input can be controlled by defining
# the FORMAT__INPUT macro.  FORMAT__INPUT's calling sequence is
# "FORMAT__INPUT(buf,result,max_size)".  Its action is to place up to
# max_size characters in the character array buf and return in the
# integer variable result either the number of characters read or the
# constant FORMAT__NULL (0 on Unix systems) to indicate EOF.  The default
# FORMAT__INPUT reads from the global file-pointer "format_in".
#   -- from the flex(1) man page
proc FORMAT__INPUT {buf result max_size} {
    upvar $result ret_val
    upvar $buf new_data
    if {$::format_in != ""} {
        set new_data [read $::format_in $max_size]
        set ret_val [string length $new_data]
    } else {
        set new_data ""
        set ret_val 0
    }
}

# yy_scan_string sets up input buffers for scanning in-memory
# strings instead of files.  Note that switching input sources does
# not change the start condition.
#   -- from the flex(1) man page
proc format__scan_string {str} {
    append ::format__buffer $str
    set ::format_in ""
}

# unput(c) puts the character c back onto the input stream.  It will
# be the next character scanned.
#   -- from the flex(1) man page
proc unput {c} {
    set s [string range $::format__buffer 0 [expr {$::format__index - 1}]]
    append s $c
    set ::format__buffer [append s [string range $::format__buffer $::format__index end]]
}

# Returns all but the first n characters of the current token back to
# the input stream, where they will be rescanned when the scanner
# looks for the next match.  format_text and format_leng are adjusted
# appropriately.
#   -- from the flex(1) man page
proc format_less {n} {
    set s [string range $::format__buffer 0 [expr {$::format__index - 1}]]
    append s [string range $::format_text $n end]
    set ::format__buffer [append s [string range $::format__buffer $::format__index end]]
    set ::format_text [string range $::format_text 0 [expr {$n - 1}]]
    set ::format_leng [string length $::format_text]
}

# input() reads the next character from the input stream.
#   -- from the flex(1) man page
proc input {} {
    if {[string length $::format__buffer] - $::format__index < 1024} {
       set new_buffer_size 0
       if {$::format__done == 0} {
           FORMAT__INPUT new_buffer new_buffer_size 1024
           append ::format__buffer $new_buffer
           if {$new_buffer_size == 0} {
               set ::format__done 1
           }
       }
       if $::format__done {
           if {[format_wrap] == 0} {
               return [input]
           } elseif {[string length $::format__buffer] - $::format__index == 0} {
               return {}
           }
        }
    }
    set c [string index $::format__buffer $::format__index]
    incr ::format__index
    return $c
}

# Pushes the current start condition onto the top of the start
# condition stack and switches to new_state as though you had used
# BEGIN new_state.
#   -- from the flex(1) man page
proc format__push_state {new_state} {
    lappend ::format__state_stack $new_state
}

# Pops off the top of the state stack; if the stack is now empty, then
# pushes the state "INITIAL".
#   -- from the flex(1) man page
proc format__pop_state {} {
    set ::format__state_stack [lrange $::format__state_stack 0 end-1]
    if {$::format__state_stack == ""} {
        format__push_state INITIAL
    }
}

# Returns the top of the stack without altering the stack's contents.
#   -- from the flex(1) man page
proc format__top_state {} {
    return [lindex $::format__state_stack end]
}

# BEGIN followed by the name of a start condition places the scanner
# in the corresponding start condition. . . .Until the next BEGIN
# action is executed, rules with the given start condition will be
# active and rules with other start conditions will be inactive.  If
# the start condition is inclusive, then rules with no start
# conditions at all will also be active.  If it is exclusive, then
# only rules qualified with the start condition will be active.
#   -- from the flex(1) man page
proc BEGIN {new_state {prefix format_}} {
    eval set ::${prefix}_state_stack [lrange \$::${prefix}_state_stack 0 end-1]
    eval lappend ::${prefix}_state_stack $new_state
}

# initialize values used by the lexer
set ::format_text {}
set ::format_leng 0
set ::format__buffer {}
set ::format__index 0
set ::format__done 0
set ::format__state_stack {}
BEGIN INITIAL
array set ::format__state_table {INITIAL 1}
if {![info exists ::format_in]} {
    set ::format_in "stdin"
}
if {![info exists ::format_out]} {
    set ::format_out "stdout"
}

######
# autogenerated format_lex function created by fickle
######

# Whenever yylex() is called, it scans tokens from the global input
# file yyin (which defaults to stdin).  It continues until it either
# reaches an end-of-file (at which point it returns the value 0) or
# one of its actions executes a return statement.
#   -- from the flex(1) man page
proc format_lex {} {
    upvar #0 ::format_text format_text
    upvar #0 ::format_leng format_leng
    while {1} {
        set format__current_state [format__top_state]
        if {[string length $::format__buffer] - $::format__index < 1024} {
            if {$::format__done == 0} {
                set format__new_buffer ""
                FORMAT__INPUT format__new_buffer format__buffer_size 1024
                append ::format__buffer $format__new_buffer
                if {$format__buffer_size == 0 && \
                        [string length $::format__buffer] - $::format__index == 0} {
                    set ::format__done 1
                }
            }
            if $::format__done {
                if {[format_wrap] == 0} {
                    set ::format__done 0
                    continue
                } elseif {[string length $::format__buffer] - $::format__index == 0} {
                    break
                }
            }            
        }
        set ::format_leng 0
        set format__matched_rule -1
        # rule 0: [ \n\t\b\f]+
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A([ \n\t\b\f]+)} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 0
        }
        # rule 1: \\[luLUEnt\\$]
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A(\\[luLUEnt\\$])} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 1
        }
        # rule 2: \$
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A(\$)} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 2
        }
        # rule 3: \{
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A(\{)} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 3
        }
        # rule 4: \}
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A(\})} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 4
        }
        # rule 5: \(
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A(\()} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 5
        }
        # rule 6: \)
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A(\))} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 6
        }
        # rule 7: [`:/\?]
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A([`:/\?])} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 7
        }
        # rule 8: [0-9][0-9]*
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A([0-9][0-9]*)} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 8
        }
        # rule 9: (CLIPBOARD|CURRENT_LINE|CURRENT_WORD|DIRECTORY|FILEPATH|FILENAME|LINE_INDEX|LINE_NUMBER|CURRENT_DATE)
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A((CLIPBOARD|CURRENT_LINE|CURRENT_WORD|DIRECTORY|FILEPATH|FILENAME|LINE_INDEX|LINE_NUMBER|CURRENT_DATE))} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 9
        }
        # rule 10: .
        if {$::format__state_table($format__current_state) && \
                [regexp -start $::format__index -indices -line  -- {\A(.)} $::format__buffer format__match] > 0 && \
                [lindex $format__match 1] - $::format__index + 1 > $::format_leng} {
            set ::format_text [string range $::format__buffer $::format__index [lindex $format__match 1]]
            set ::format_leng [string length $::format_text]
            set format__matched_rule 10
        }
        if {$format__matched_rule == -1} {
            set ::format_text [string index $::format__buffer $::format__index]
            set ::format_leng 1
        }
        incr ::format__index $::format_leng
        # workaround for Tcl's circumflex behavior
        if {[string index $::format_text end] == "\n"} {
            set ::format__buffer [string range $::format__buffer $::format__index end]
            set ::format__index 0
        }
        switch -- $format__matched_rule {
            0 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos [string length $format_text]
  return $::CHAR
            }
            1 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos [string length $format_text]
  switch [string index $format_text 1] {
    l       { return $::LOWER }
    u       { return $::UPPER }
    L       { return $::LOWER_BLOCK }
    U       { return $::UPPER_BLOCK }
    E       { return $::END_BLOCK }
    n       { return $::NEWLINE }
    t       { return $::TAB }
    default {
      set ::format_lval $format_text
      return $::CHAR
    }
  }
            }
            2 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos
  return $::DOLLAR_SIGN
            }
            3 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos
  return $::OPEN_BRACKET
            }
            4 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos
  return $::CLOSE_BRACKET
            }
            5 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos
  return $::OPEN_PAREN
            }
            6 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos
  return $::CLOSE_PAREN
            }
            7 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos
  return $format_text
            }
            8 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos [string length $format_text]
  return $::DECIMAL
            }
            9 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos [string length $format_text]
  return $::VARNAME
            }
            10 {
set ::format_lval $format_text
  set ::format_begpos $::format_endpos
  incr ::format_endpos [string length $format_text]
  return $::CHAR
            }
            default
                { ECHO }
        }
    }
    return 0
}
######
# end autogenerated fickle functions
######


